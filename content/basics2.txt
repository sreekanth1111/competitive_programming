2d vector

vector<vector<int>(col)>mat(row);

sets can't have duplicate elements

multiset<int> st;

it stores duplicate elements

map can't have duplicate keys

multimap can have duplicate keys

multimap<int,int> mp;

stack<int> st;

st.push(10) st.top() st.pop() st.size() st.empty()

Recursion & Memoization

for fibonocci series time complexity will be O(2^n) because we calculate the 

intermediate values each and every time

int fib(int n){
    if(n<=1){
        return n;
    }
    return fib(n-1)+fib(n-2);
}

so to reduce time complexity from O(2^n) to O(n) we use Memoization

dp[n] is initialized -1 indicating that values are empty

int fib(int n){
    if(n<=1){
        return n;
    }
    if(dp[n]!=-1){
        return dp[n];
    }
    dp[n] = fib(n-1) + fib(n-2);
    return dp[n];
}

here if we want fib(4) then we check whether the values of fib(3) & fib(2)

exist or not . If exist then that values else we compute.

But in previous case each and every time we calculate the values of fib(n-1) 

and fib(n-2) bcz we don't store the values.


subarray is contiguous part of the array

subsequence is non contiguous but in order

subset is any order

a = [4,2,1,3,5]

[4,2,1] is subarray but [4,1,3] is not subarray

[4,1,3] is subsequence but [4,3,1] is not subsequence


recursion - trying all ways

backtracking - pick something , do something , pop (backtrack to the previous state)

to print all subsequences of an array using backtracking

void pick(int ind, vector<int>&vec){
    if(ind==n){
        print(vec);
        return;
    }
    vec.push_back(a[ind]); // pick the element at each index
    pick(ind+1,vec);

    vec.pop_back();  // pop the inserted element 
    pick(ind+1,vec);
}

time is O(n*2^n) n-to print vector 2^n - no of subsets

backtracking will work only if n is less than 20 else it gives tle


1 index based prefix sum

vector<int> a(n+1), p(n+1,0);

for(int i=1; i<=n; i++){
    p[i] = p[i-1] + a[i];
}

to add 1 from index l to r 

add 1 at l and subtract 1 at r+1

and perform prefix sum



prefix sum for 2d array

for(int i=1; i<=n; i++){
    for(int j=1; j<=m; j++){
        p[i][j] = a[i][j] + p[i-1][j] + p[i][j-1] - p[i-1][j-1];
    }
}

time complexity is O(mn)

Kadane algorithm :- It is used to find the maximum sum of the subarray in 

O(n) time

maxEnding = a[0];
maxsum = a[0];

for(int i=1; i<n; i++){
    maxEnding = max(maxEnding+a[i],a[i]);
    maxsum = max(maxsum,maxEnding);
}

if maxEnding is -ve then we start we new subarray
else we extend the subarray

maxsum stores the maxium sum of the subarray 
while maxEnding stores the sum of the subarray


Sieve Eratosthenes

vector<bool> prime(n+1,1);
prime[0] = prime[1] = false;
for(int i=2; i*i<n; i++){
    if(prime[i]){
        for(int j=i*i; j<n; j+=i) prime[j] = false;
    }
}

regular method takes O(n*sqrt(n)) time but this method takes O(nloglogn) time

Prime factorisation using Sieve

vector<int> spf(100,-1);
for(int i=2; i<100; i++){
    if(spf[i]==-1){
        for(int j=i; j<100; j+=i){
            if(spf[j]==-1) spf[j] = i;
        }
    }
}

int n = 20;
while(n>1){
    cout << spf[n] << " ";
    n /= spf[n];
}

here spf is smallest prime factor of a number  

building spf array time is O(nloglogn)

factorising a number is O(logn)

so total time is O(nloglogn)


gcd value

int gcd(int a, int b){
    return (b==0 ? a : gcd(b,a%b));
}

here a is greater than or equal to b 

lcm value 

lcm = (a*b)/gcd(a,b);


Modular Arithmetic

(a+b)%m = (a%m + b%m)%m

(a-b)%m = (a%m - b%m + m)%m

(a*b)%m = (a%m * b%m)%m


Fast Exponentiation

ind mod_mul(int a, int b, int m){
    return (a%m * b%m)%m;
}

int mod_expo(int a, int b, int m){
    if(b==0) return 1;
    int res = mod_expo(a,b/2,m);
    res = mod_mul(res,res,m);
    if(b%2==1) res = mod_mul(res,a,m);
    return res;
}

int mod_inv(int a, int m){
    return mod_expo(a, m-2, m);
}

int mod_div(int a, int b, int m){
    return mod_mul(a, mod_inv(b,m), m);
}

here m is prime 

according to fermat theorem a^(m-1) = 1 (mod m);

this leads to a^(m-2) = inv(a);

int ncr(int n, int r){
    if(r<0 or r>n) return 0;
    return mod_div(fact[n], mod_mul(fact[r],fact[n-r],m) ,m);
}

long long main(){

    fact[0]=1;
    for(int i=1; i<n; i++) fact[i] = mod_mul(fact[i-1], i, m);
}




