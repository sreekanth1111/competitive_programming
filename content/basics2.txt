2d vector

vector<vector<int>(col)>mat(row);

sets can't have duplicate elements

multiset<int> st;

it stores duplicate elements

map can't have duplicate keys

multimap can have duplicate keys

multimap<int,int> mp;

stack<int> st;

st.push(10) st.top() st.pop() st.size() st.empty()

Recursion & Memoization

for fibonocci series time complexity will be O(2^n) because we calculate the 

intermediate values each and every time

int fib(int n){
    if(n<=1){
        return n;
    }
    return fib(n-1)+fib(n-2);
}

so to reduce time complexity from O(2^n) to O(n) we use Memoization

dp[n] is initialized -1 indicating that values are empty

int fib(int n){
    if(n<=1){
        return n;
    }
    if(dp[n]!=-1){
        return dp[n];
    }
    dp[n] = fib(n-1) + fib(n-2);
    return dp[n];
}

here if we want fib(4) then we check whether the values of fib(3) & fib(2)

exist or not . If exist then that values else we compute.

But in previous case each and every time we calculate the values of fib(n-1) 

and fib(n-2) bcz we don't store the values.


subarray is contiguous part of the array

subsequence is non contiguous but in order

subset is any order

a = [4,2,1,3,5]

[4,2,1] is subarray but [4,1,3] is not subarray

[4,1,3] is subsequence but [4,3,1] is not subsequence


recursion - trying all ways

backtracking - pick something , do something , pop (backtrack to the previous state)

to print all subsequences of an array using backtracking

void pick(int ind, vector<int>&vec){
    if(ind==n){
        print(vec);
        return;
    }
    vec.push_back(a[ind]); // pick the element at each index
    pick(ind+1,vec);

    vec.pop_back();  // pop the inserted element 
    pick(ind+1,vec);
}

time is O(n*2^n) n-to print vector 2^n - no of subsets

backtracking will work only if n is less than 20 else it gives tle


1 index based prefix sum

vector<int> a(n+1), p(n+1,0);

for(int i=1; i<=n; i++){
    p[i] = p[i-1] + a[i];
}

prefix sum for 2d array

for(int i=1; i<=n; i++){
    for(int j=1; j<=m; j++){
        p[i][j] = a[i][j] + p[i-1][j] + p[i][j-1] - p[i-1][j-1];
    }
}

time complexity is O(mn)

Kadane algorithm :- It is used to find the maximum sum of the subarray in 

O(n) time

maxEnding = a[0];
maxsum = a[0];

for(int i=1; i<n; i++){
    maxEnding = max(maxEnding+a[i],a[i]);
    maxsum = max(maxsum,maxEnding);
}

if maxEnding is -ve then we start we new subarray
else we extend the subarray

maxsum stores the maxium sum of the subarray 
while maxEnding stores the sum of the subarray




