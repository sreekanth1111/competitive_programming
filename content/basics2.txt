2d vector

vector<vector<int>(col)>mat(row);

sets can't have duplicate elements

multiset<int> st;

it stores duplicate elements

map can't have duplicate keys

multimap can have duplicate keys

multimap<int,int> mp;

stack<int> st;

st.push(10) st.top() st.pop() st.size() st.empty()

Recursion & Memoization

for fibonocci series time complexity will be O(2^n) because we calculate the 

intermediate values each and every time

int fib(int n){
    if(n<=1){
        return n;
    }
    return fib(n-1)+fib(n-2);
}

so to reduce time complexity from O(2^n) to O(n) we use Memoization

dp[n] is initialized -1 indicating that values are empty

int fib(int n){
    if(n<=1){
        return n;
    }
    if(dp[n]!=-1){
        return dp[n];
    }
    dp[n] = fib(n-1) + fib(n-2);
    return dp[n];
}

here if we want fib(4) then we check whether the values of fib(3) & fib(2)

exist or not . If exist then that values else we compute.

But in previous case each and every time we calculate the values of fib(n-1) 

and fib(n-2) bcz we don't store the values.


subarray is contiguous part of the array

subsequence is non contiguous but in order

subset is any order

a = [4,2,1,3,5]

[4,2,1] is subarray but [4,1,3] is not subarray

[4,1,3] is subsequence but [4,3,1] is not subsequence


recursion - trying all ways

backtracking - pick something , do something , pop (backtrack to the previous state)

to print all subsequences of an array using backtracking

void pick(int ind, vector<int>&vec){
    if(ind==n){
        print(vec);
        return;
    }
    vec.push_back(a[ind]); // pick the element at each index
    pick(ind+1,vec);

    vec.pop_back();  // pop the inserted element 
    pick(ind+1,vec);
}

time is O(n*2^n) n-to print vector 2^n - no of subsets

backtracking will work only if n is less than 20 else it gives tle


1 index based prefix sum

vector<int> a(n+1), p(n+1,0);

for(int i=1; i<=n; i++){
    p[i] = p[i-1] + a[i];
}

to add 1 from index l to r 

add 1 at l and subtract 1 at r+1

and perform prefix sum



prefix sum for 2d array

for(int i=1; i<=n; i++){
    for(int j=1; j<=m; j++){
        p[i][j] = a[i][j] + p[i-1][j] + p[i][j-1] - p[i-1][j-1];
    }
}

time complexity is O(mn)

Kadane algorithm :- It is used to find the maximum sum of the subarray in 

O(n) time

maxEnding = a[0];
maxsum = a[0];

for(int i=1; i<n; i++){
    maxEnding = max(maxEnding+a[i],a[i]);
    maxsum = max(maxsum,maxEnding);
}

if maxEnding is -ve then we start we new subarray
else we extend the subarray

maxsum stores the maxium sum of the subarray 
while maxEnding stores the sum of the subarray


Sieve Eratosthenes

vector<bool> prime(n+1,1);
prime[0] = prime[1] = false;
for(int i=2; i*i<n; i++){
    if(prime[i]){
        for(int j=i*i; j<n; j+=i) prime[j] = false;
    }
}

regular method takes O(n*sqrt(n)) time but this method takes O(nloglogn) time

Prime factorisation using Sieve

vector<int> spf(100,-1);
for(int i=2; i<100; i++){
    if(spf[i]==-1){
        for(int j=i; j<100; j+=i){
            if(spf[j]==-1) spf[j] = i;
        }
    }
}

int n = 20;
while(n>1){
    cout << spf[n] << " ";
    n /= spf[n];
}

here spf is smallest prime factor of a number  

building spf array time is O(nloglogn)

factorising a number is O(logn)

so total time is O(nloglogn)


gcd value

int gcd(int a, int b){
    return (b==0 ? a : gcd(b,a%b));
}

here a is greater than or equal to b 

lcm value 

lcm = (a*b)/gcd(a,b);


Modular Arithmetic

(a+b)%m = (a%m + b%m)%m

(a-b)%m = (a%m - b%m + m)%m

(a*b)%m = (a%m * b%m)%m


Fast Exponentiation

ind mod_mul(int a, int b, int m){
    return (a%m * b%m)%m;
}

int mod_expo(int a, int b, int m){
    if(b==0) return 1;
    int res = mod_expo(a,b/2,m);
    res = mod_mul(res,res,m);
    if(b%2==1) res = mod_mul(res,a,m);
    return res;
}

int mod_inv(int a, int m){
    return mod_expo(a, m-2, m);
}

int mod_div(int a, int b, int m){
    return mod_mul(a, mod_inv(b,m), m);
}

here m is prime 

according to fermat theorem a^(m-1) = 1 (mod m);

this leads to a^(m-2) = inv(a);

int ncr(int n, int r){
    if(r<0 or r>n) return 0;
    return mod_div(fact[n], mod_mul(fact[r],fact[n-r],m) ,m);
}

long long main(){

    fact[0]=1;
    for(int i=1; i<n; i++) fact[i] = mod_mul(fact[i-1], i, m);
}



Two pointers problem - time complexity is O(n+m) 

where O(n) is time complexity for pointer 1 and 

O(m) is time complexity for pointer 2

Example :- Three sum problem i.e sum of 3 elements should be equal to x

sort(a.begin(),a.end())

for(int i=0; i<n; i++){ 

    int k = n-1;
    for(int j=i+1; j<n; j++){

        int rem = x-(a[i]+a[j]);

        while(j<k && k>rem){
            k--;
        }

        if(j<k && k<n && a[k] == rem){
            cout << a[i] << " " << a[j] << " " << a[k] << endl;;
        }
    }
}

here time complexity is O(n*(n+n)) i.e O(n^2) bcz

j loop time complexity is O(n+n) not O(n^2) as k

runs for n times for all j's combined not for each j


Recursion 

Example - divide array into 2 groups such that the absolute difference between the 

sum of group 1 and sum of group2 is minimum

int solve(int i = 0, int currentsum = 0){
    if(i==n){
        int othersum = totalsum - currentsum;
        return abs(currentsum-othersum);
    }

    return min(
        solve(i+1,currentsum+a[i]),
        solve(i+1,currentsum)
    );
}


Binary Search

1) Basic method

Finding first index of target

int search(vector<int> a, int target){
    int l = 0, r = a.size()-1;
    while(l<r){

        int mid = (left+right)/2;
        if(a[mid]<target) l = mid+1;
        else r = mid;
    }
    return (a[r]==target ? r : -1);
}

Finding last index of target

int search(vector<int> a, int target){
    int l = 0, r = a.size()-1;
    while(l<r){

        int mid = (left+right+1)/2;
        if(a[mid]<=target) l = mid;
        else r = mid-1;
    }
    return (a[l]==target ? l : -1);
}

2) some variation 

Finding first index of target

int search(vector<int> a, int target){

    int ans = 0;
    int l = 0, r = a.size()-1;
    while(l<=r){
        int mid = (left+right)/2;
        if(a[mid]<target){
            l = mid+1;
        } 
        else{
            ans = r;
            r = mid-1;
        }
    }
    return ans;
}

Finding last index of target

int search(vector<int> a, int target){

    int ans = 0;
    int l = 0, r = a.size()-1;
    while(l<=r){
        int mid = (left+right)/2;
        if(a[mid]<=target){
            ans = l;
            l = mid+1;
        } 
        else{
            r = mid-1;
        }
    }
    return ans;
}

3) Simple method - Here l points to last true and r points to first false

It is based on predicate function

First index of target

int l = -1, r = a.size();
while(r-l>1){
    int mid = (l+r)/2;
    (a[mid]<target) ? l = mid : r = mid;
}

if(r!=n && a[r]==target) return r;
else return -1;

Last index of target

int l = -1, r = a.size();
while(r-l>1){
    int mid = (l+r)/2;
    (a[mid]<=target) ? l = mid : r = mid;
}

if(l!=-1 && a[l]==target) return l;
else return -1;


Bit Manipulation

In C++  ~x is -(x+1)

If a binary number consists only 1's then the value of the number is -1

1111...111 is -1
1111...110 is -2
1111...101 is -3 and so on

Bit Mask :- A bitmask is a sequence of N bits that encode a subset , where the

element is taken if a bit is set, and not taken if a bit is unset

in 10110 , 1,2,4 indices are taken and 0,3 are not taken.

instead of using recursion to generate all possible subsets of an array

we can use this method. 


for(int i=0; i<n; i++){
    cin >> a[i];
}

for(int i=0; i<(1<<n); i++){
    for(int j=0; j<n; j++){
        if((i>>j) & 1){
            cout << a[i] << " ";
        }
    }
    cout << endl;
}

Greedy Algorithms

Kadane Algorithm - to find maximum sum of a subset in array in O(n) time

int sum = 0;
int max_sum = INT_MIN;
for(int i=0; i<n; i++){
    sum += a[i];
    max_sum = max(max_sum,sum);
    if(sum<0) sum = 0;
}

cout << max_sum << endl;













