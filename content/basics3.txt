String hashing - converting the string to an integer.

it is used for checking whether two strings are equal or not

Here we took 31 instead of 26 bcz 31 is a prime and 26 is not a prime.

31 gives less no of collisions.

const int MOD = 1e9+7;
long long get_hash(string s){
    long long h = 0;
    for(char c : s) h = (h*31 + (c-'a'+1)) % MOD;
    return h;
}

cout << (get_hash("abc") == get_hash("dbc")) << endl; 

1) we can use this when we are given with Q queries and

check for s[i1,j1] = s[i2,j2] for each query

we can do this in O(n+q) time using above method and prefix hashing

like when we are calculating hash value we store intermediate values in the prefix array

hash value of s[i1,j1] = s[j1] - (s[i1-1] * 31^(j1-i1+1))

2) Rabin Karp (Pattern Matching)

s = abcbcb , t = bcb find no of occurrence of t in s

we can do this using sliding window + prefix hashing

s[0:3] == t, s[1:4] == t , ... and so on 

we can find hash value of s[1:4] using prefix hashing

s[1:4] = p[4] - (p[0] * 31^(4)) 

so we can do pattern matching in O(n+m) time 

bruteforce will take O(n*m) time


Priority queue pair trick to sort the pair array where x should be sorted according

to ascending order and y should be according to descending order

Priority_queue<pair<int,int>> pq;
for(int i=0; i<n; i++){
    int a,b; cin >> a >> b;
    pq.push({-a,b});
}

while(pq.empty() == false){
    int a = -pq.top.first;
    int b = pq.top.second;
    cout << a << b;
    pq.pop();
}

Priority queue always stores in descending order. so when we multiply by -1 

this order will be reversed i.e, max ele becomes min and min ele becomes max

so thereby we get initial min ele at top of Priority queue

and when we are printing we again multiply by 1

to get ascending order


Ternery Search

int eps = 1e-9
int l = 0, r = 1e9;
while(r-l>eps){
    int m1 = l + (r-l)/3;
    int m2 = r - (r-l)/3;
    if(f(m1)<f(m2)) l = m1;
    else r = m2;
}

cout << l << endl;

f(m1)<f(m2) is just an condition we can put anything there 

according to our requirement


Interative problems :- In Interative problems, you get answers for your queries.

output a query, an input will be given as an answer.

remove fastio and use endl (not '\n') when solving Interative problems

endl = '\n' + cout.flush()


Two pointers :-

If calculating an answer takes O(n^2) time then

applying binary search reduces to O(nlogn) time

applying two pointers technique reduces to O(n) time

if we can solve a problem using binary search then we can 

definitively a solve this problem using two pointers

Ex :- Longest length of subarray such that sum <= K

while(j<n){
    sum += arr[j];
    while(i<=j && sum>k){
        sum -= arr[i];
        i++;
    }
    ans = max(ans,j-i+1);
    j++;
}

Policy based data structure :- It works same as set except that it is used

to access the element at particular index in O(logn) time

whereas set takes O(n) time .

pbds a;
for(auto i : arr){
    a.insert(i);
}

cout << a.find_by_order(i) << endl; // prints elements at index i in O(logn) time

cout << a.order_of_key(ele) << endl; // prints index of the element

You need to include some libraries to use pbds . so just chatgpt it before using

Example :- to find median of every window K using sliding window technique

pbds A;
for(int i=0; i<n; i++){
    A.insert({arr[i],i});
}

ans.pb(*(A.find_by_order(k/2)).first);
for(int i = 1; i<=n-k; i++){
    A.insert({arr[i+k-1],i+k-1});
    A.erase({arr[i-1],i-1});
    ans.pb(*(A.find_by_order(k/2)).first);
}

for(auto i : ans) cout << i << endl;


Gcd :-

gcd(a,b) = gcd(abs(a),abs(b));

gcd(a,b) = gcd(a,b-a) = gcd(a,b-2a) = ... = gcd(a,b-na);

where b-na >= 0;

gcd(a,b) = gcd(b%a,a);

lcm(a,b) * gcd(a,b) = a*b;

Euclid's Extended Algorithm :-

gcd(a,b) = ax+by

int gcd(int a, int b, int &x, int &y){
    if(a==0){
        x = 0;
        y = 1;
        return b;
    }
    int x1,y1;
    int g = gcd(b%a,a,x1,y1);
    x = y1 - (b/a)*x1;
    y = x1;
    return g;

    
}

regular method takes O(n*sqrt(n)) time but this method takes O(nloglogn) time

Prime factorisation using Sieve

vector<int> spf(100,-1);
for(int i=2; i<100; i++){
    if(spf[i]==-1){
        for(int j=i; j<100; j+=i){
            if(spf[j]==-1) spf[j] = i;
        }
    }
}

int n = 20;
while(n>1){
    cout << spf[n] << " ";
    n /= spf[n];
}

here spf is smallest prime factor of a number  

building spf array time is O(nloglogn)

factorising a number is O(logn)

so total time is O(nloglogn)


Coordinate shifting :-

suppose we want to check prime or not in the range of l to r 

not starting from 1.

int l,r; cin >> l >> r;
int size = r-l+1;
int dummy[size];
for(int i=0; i<n; i++) dummy[i] = 1;

for(int i=2; i*i<=r; i++){
    if(sieve[i]==1){
        int initial = (l/i) * i;
        if(intital < 1) initial += i;
        initial = max(i*i,initial);
        for(int j=initial-1; j<size; j+=i){
            dummy[j] = 0;
        }
    }
}
int cnt = 0;
for(int i=0; i<size; i++){
    if(dummy[i]) cnt++;
}

cout << cnt << endl;


Combinatorics :-

The no of ways to reach from (1,1) to (n,m) is (n+m-2)C(n-1)

i.e (n+m-2)!/((n-1)!(m-1)!)

the no of ways of dividing a number n into sum of k non zero numbers is (n-1)C(k-1)

the no of ways of dividing a number n into sum of k non negative numbers is (n+k-1)C(k-1)

the above are derived using distribution principle in permutations and combinations

x1 + x2 + .. + xk = n 

for non zero , no of ways = ((n-k)+k-1)C(k-1)

bcz each number has value of atlest 1 so we subtract k from n

for non negative , no of ways = (n+k-1)C(k-1)

here each number can be >= 0 so need subtract k from n
 
Dynamic Programming :-

Ex :- Fibonocci Series

int Fibonocci(int n){
    if(n==1 || n==2){
        return 1;
    }
    if(dp[n]!=-1){
        return dp[n];
    }
    return dp[n] = Fibonocci(n-1) + Fibonocci(n-2);
}

Ex :- Grid problem to reach from (0,0) to (n-1,m-1)

int f(int i, int j){
    if(i>=n || j>=m) return INF;
    if(i==n-1 && j==m-1) return grid[i][j];
    if(dp[i][j]!=-1) return dp[i][j];

    return dp[i][j] = grid[i][j] + min(f(i+1,j),f(i,j+1));
}


State :- A subproblem that we want to solve. Here subproblem should have a meaning.

Transition :- calculating the answers for a state by using the answers 

of other smaller states.

Ex :- 

state - dp[i][j] or f(i,j)

transition - dp[i][j] = dp[i-1][j] + dp[i][j-1];










