String hashing - converting the string to an integer.

it is used for checking whether two strings are equal or not

Here we took 31 instead of 26 bcz 31 is a prime and 26 is not a prime.

31 gives less no of collisions.

const int MOD = 1e9+7;
long long get_hash(string s){
    long long h = 0;
    for(char c : s) h = (h*31 + (c-'a'+1)) % MOD;
    return h;
}

cout << (get_hash("abc") == get_hash("dbc")) << endl; 

1) we can use this when we are given with Q queries and

check for s[i1,j1] = s[i2,j2] for each query

we can do this in O(n+q) time using above method and prefix hashing

like when we are calculating hash value we store intermediate values in the prefix array

hash value of s[i1,j1] = s[j1] - (s[i1-1] * 31^(j1-i1+1))

2) Rabin Karp (Pattern Matching)

s = abcbcb , t = bcb find no of occurrence of t in s

we can do this using sliding window + prefix hashing

s[0:3] == t, s[1:4] == t , ... and so on 

we can find hash value of s[1:4] using prefix hashing

s[1:4] = p[4] - (p[0] * 31^(4)) 

so we can do pattern matching in O(n+m) time 

bruteforce will take O(n*m) time


Priority queue pair trick to sort the pair array where x should be sorted according

to ascending order and y should be according to descending order

Priority_queue<pair<int,int>> pq;
for(int i=0; i<n; i++){
    int a,b; cin >> a >> b;
    pq.push({-a,b});
}

while(pq.empty() == false){
    int a = -pq.top.first;
    int b = pq.top.second;
    cout << a << b;
    pq.pop();
}

Priority queue always stores in descending order. so when we multiply by -1 

this order will be reversed i.e, max ele becomes min and min ele becomes max

so thereby we get initial min ele at top of Priority queue

and when we are printing we again multiply by 1

to get ascending order


Ternery Search

int eps = 1e-9
int l = 0, r = 1e9;
while(r-l>eps){
    int m1 = l + (r-l)/3;
    int m2 = r - (r-l)/3;
    if(f(m1)<f(m2)) l = m1;
    else r = m2;
}

cout << l << endl;

f(m1)<f(m2) is just an condition we can put anything there 

according to our requirement


Interative problems :- In Interative problems, you get answers for your queries.

output a query, an input will be given as an answer.

remove fastio and use endl (not '\n') when solving Interative problems

endl = '\n' + cout.flush()


Two pointers :-

If calculating an answer takes O(n^2) time then

applying binary search reduces to O(nlogn) time

applying two pointers technique reduces to O(n) time

if we can solve a problem using binary search then we can 

definitively a solve this problem using two pointers

Ex :- Longest length of subarray such that sum <= K

while(j<n){
    sum += arr[j];
    while(i<=j && sum>k){
        sum -= arr[i];
        i++;
    }
    ans = max(ans,j-i+1);
    j++;
}

Policy based data structure :- It works same as set except that it is used

to access the element at particular index in O(logn) time

whereas set takes O(n) time .

pbds a;
for(auto i : arr){
    a.insert(i);
}

cout << a.find_by_order(i) << endl; // prints elements at index i in O(logn) time

cout << a.order_of_key(ele) << endl; // prints index of the element

You need to include some libraries to use pbds . so just chatgpt it before using

Example :- to find median of every window K using sliding window technique

pbds A;
for(int i=0; i<n; i++){
    A.insert({arr[i],i});
}

ans.pb(*(A.find_by_order(k/2)).first);
for(int i = 1; i<=n-k; i++){
    A.insert({arr[i+k-1],i+k-1});
    A.erase({arr[i-1],i-1});
    ans.pb(*(A.find_by_order(k/2)).first);
}

for(auto i : ans) cout << i << endl;


Gcd :-

gcd(a,b) = gcd(abs(a),abs(b));

gcd(a,b) = gcd(a,b-a) = gcd(a,b-2a) = ... = gcd(a,b-na);

where b-na >= 0;

gcd(a,b) = gcd(b%a,a);

lcm(a,b) * gcd(a,b) = a*b;

Euclid's Extended Algorithm :-

gcd(a,b) = ax+by

int gcd(int a, int b, int &x, int &y){
    if(a==0){
        x = 0;
        y = 1;
        return b;
    }
    int x1,y1;
    int g = gcd(b%a,a,x1,y1);
    x = y1 - (b/a)*x1;
    y = x1;
    return g;
}






