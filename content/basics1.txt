Basics of c++

To output the data in c++

cout << value1 << value2 << value3 << endl;

endl is used for new line


Bool Data type 

bool a = true

cout << a << endl;

it prints 1 as output instead of true. so here true will be printed as 1 and 

false will be printed as 0.


Input in C++

cin >> value1 >> value2 >> value3 >> endl;


For loops 


for(s1;s2;s3){}


while loops

while(condition){}


Arrays 

int arr[5] = {1, 2, 34, 5, 6};

to print values of array 

for(int i=0; i<n; i++){
    cout << arr[i] << endl;
}

or we can use this

for(auto val : arr){
    cout << val << endll;
}

here val represents the element of the array not the index.


if the array is double then we should use &

for(auto &val : arr){
    cout << val << endl;
}


Range of data types 

1) Int :- -2^32 to 2^32 - 1

it will be appromately equal to 10^9 and
long int will be same as int

2 ) long long int : -2^64 to 2^64 - 1

it will be appromately equal to 10^18

so whenever the consraints will be 10^9 then use int and 
            the constraints will be 10^18 then use long long int

3) Float will be 7 digits
   Double will be 15 digits
   long double will be 18 digits


NameSpace :- It contains various variables and functions

using namespace std; will be used frequently

if we dont use above statement then we have to use like this 

std :: cin >> val >> endl;

at every statement


Header Files :- It contains various functions and etc

#include <iostream> will be used for inputs and outputs

but if we declare like this then we have to define many statements for various uses 

like one for strings one for maps and etc.


#include <bits/stdc++.h> will be used in the competitive programming.

this statement includes all libraries we require in the program and 

we dont need to include any other statements.

use this in cp to save the time

but don't use this in development.


ceil(a/b) = (a+b-1)/b


Time Complexity

1second ~ 10^7 to 10^9 operations depends on quality of the code

Elementary Operations takes constant time

int a,b,c,d;

res = (a+b+c+d)/4; is an Elementary Operation

string s, t;

if(s<t){
    cout << s << endl;
}

it is not an Elementary Operation

cin >> s is not an Elementary Operation . it takes O(N) time

string operations are not Elementary


in general , O(100000n^2) will be treated as O(n^2)

but if time limit per test is like say 1 second or say a 
finite amount of time then O(100000N^2) will be treated differently than O(n^2)


String s = "abc";

s[1] = "a"; this is not allowed

s[1] = 'a'; this is allowed 

'a' is literal "a" is string

reverse(s.begin(),s.end()) reverses the string

s.begin takes the index 0 and s.end taked the index n and n is exclusive

cout << (s == t ? "YES" : "NO") << endl; ternery operator

transform(s.begin(), s.end(), s.begin(), ::tolower);

it converts each and every letter of the string to lower case


Finding whether a num is prime or not

1) Brute Force O(n) time

bool prime(int n){
    for(int i=2; i<n; i++){
        if(n%i==0){
            return false;
        }
    }
    return n>1;
}

2) square root method O(sqrt(n))

bool prime(int n){
    for(int i=2; i*i<=n; i++){
        if(n%i==0){
            return false;
        }
    }
    return n>1;
}

Sieves of Eratosthenes Method to find all prime numbers within a Range
takes O(nloglogn) time we can appromately take it as O(n)

void sieve(int n){
    bool primes[n+1];

    fill(primes,primes+n+1,true); fills with true

    primes[0] = false;
    primes[1] = false;

    for(int i=2; i*i<=n; i++){
        if(primes[i]){
            for(int j=i*i; j<=n; j+=i){
                primes[i] = false;
            }
        }
    }
}

Modular Arithmetic :- It is used to avoid overflow

-13%5 should be 2 but in c++ it gives -3 

so add it to 5 to get correct answer

result = (r + m)%m

-13/5 should be -3 but in c++ it gives -2

so subtract it . result = -2-1 = -3


const int mod = 1e9 + 7;

define this and use mod in place of m

addition (a+b)%m = (a%m + b%m)%m

multiplication (a*b)%m = ((a%m) * (b%m))%m

subtraction (a-b)%m = ((a%m - b%m)%m + m)%m



Prime Factorization - finding the prime factors of a number

vector<int> factor(int n){
    vector<int> facts;
    for(int i=2; i*i<=n; i++){
        while(n%i == 0){
            facts.push_back(i);
            n /= i;
        }
    }

    if(n!=1){
        facts.push_back(n);
    }
}


pow(a,b) this inbuilt function takes O(b) time

so we write a new function which takes O(logb) time

int pow(int a, intb){
    if(b==0){
        return 1;
    }

    int half_power = pow(a,b/2);

    if(b%2==0){
        return half_power * half_power;
    }
    else{
        return half_power * half_power * a;
    }
}

gcd - greatest common divisor

int gcd(int a, int b){
    if(a == 0){
        return b;
    }

    return gcd(b%a, a);
}

for numbers of a fibonocci series gcd will take O(n) time

lcm(a,b) = (a*b)/gcd(a,b);

gcd(a,b,c) = gcd(gcd(a,b),c);

lcm(a,b,c) = lcm(lcm(a,b),c);


Prefix sum stores the sum of the prefix of an array at each index

takes O(n) time

int p[n], p[0] = a[0];
for(int i=1; i<n; i++){
    p[i] = p[i-1] + a[i];
}

Binary Search - O(logn) time

use this if target is present in the vector

bool binarysearch(vector<int>a, int k){
    left = 0; right = a.size()-1;
    while(left<=right){
        int mid = (left+right)/2;

        if(a[mid] == k) return true;
        else if(a[mid]>k) right = mid-1;
        else left = mid+1;
    }
    return false;
}

to find the last index of the target

bool binarysearch(vector<int>a, int k){
    left = 0; right = a.size()-1;
    while(left<right){
        int mid = (left+right+1)/2; // mid will be ceil function (a+b-1)/b

        if(a[mid]<=k) left=mid;
        else right = mid-1;
    }
    return (left==k) ? left : -1;
}

to find the first index of the target

bool binarysearch(vector<int>a, int k){
    left = 0; right = a.size()-1;
    while(left<right){
        int mid = (left+right)/2;  // mid will be floor function

        if(a[mid]>=k) right=mid;
        else left = mid+1;
    }
    return (left==k) ? left : -1;
}

when (l+r)/2 overflows use l + (r-l)/2


alternative binary Search - better than traditional binary Search
and never goes into infinite loop

l = -1, r = n;
while(r-l>1){
    m = (l+r)/2;
    if(a[m]<target){
        l = m;
    }
    else{
        r = m;
    }
}

when u want first index of target use the above 

and r will be the index

when u want last index of the target use

a[i] <= target and l will be the index


lower_bound returns the index of the first element that is >= target

lower_bound(v.begin(),v.end(),target);

upper_bound returns the index of the first element that is > target

upper_bound(v.begin(),v.end(),target);

these functions are similar to the binary search 

so we can use these functions in place of binary search


If we can able to manage to deduce the array into continuous of true values

and then continuous false values or vice versa using predicate function 

even though the array is not increasing or decreasing then 

we can do a binary search on it.


Standard template library (STL) is a set of classes and functions to perform

various tasks.

pair<int,int> p = {1,5};

pair is used to store two values int,int or int, string or any other


unlike arrays, vectors can be resized

v.begin() points to index 1 and v.end() points to index N

v.insert(v.begin()+1,4) inserts 4 at position 2

v.erase(v.begin()+1) removes the element at position 2

v.clear() deletes entire vector

v.size() returns the size of the vector i.e, no of elements in the vector

v.empty() return true if the vector is empty


sets store the elements in ascending order

insertion, deletion and updation takes O(logn) time 

because it uses binary search

map<int,int> mp;

mp[1] = 5;
mp[1000] = 3;

it only stores above elements . it doesn't contain any elements btw

1 and 1000

to iterate 

for(auto i:mp) cout << i.first << i.second << endl;

for(auto [a,b]:mp) cout << a << b;

maps also stores in ascending order similar to sets

both sets and maps doesn't preserve our orginal order

mp.find("a") == mp.end() it indicates "a" is not present

else it exists


ordered set takes O(logn) time which stores in sorted order

unordered set takes O(1) for all operations insertion deletion searching

unordered_set<int> s = {1,2,3,4};

unordered maps is similar to maps but doesnt store in sorted order and performs

operations in O(1) time

in unordered map we can use pair and vector and other

but in unordered set we can't use the pair and vector inside it

both of these is based on hash function 










